#install.packages("normalregMix2Test_1.0.tar.gz", repos = NULL, type="source")
library(snow)
library(doParallel)
library(Rmpi)
library(normalregMix2Test)

# Returns a misclassification rate given two components i, j(=i+1)
# where phi_i = c(alpha_i, mu_i, sigma_i) 
GetOmegaIJ <- function(phi_i, phi_j) {
	alpha_i <- phi_i[1]
	alpha_j <- phi_j[1]
	mu_i <- phi_i[2]
	mu_j <- phi_j[2]
	sigma_i <- phi_i[3]
	sigma_j <- phi_j[3]
	
	c1 <- sigma_j*(mu_j - mu_i)/(sigma_j^2-sigma_i^2)
	c2 <- sigma_i^2*(mu_j - mu_i)^2/(sigma_j^2-sigma_i^2)^2
	c2 <- sigma_i^2/(sigma_j^2 - sigma_i^2)*2*log(alpha_i*sigma_j/alpha_j/sigma_i) + c2
	sq_c2 = sqrt(max(c2,0))
	
	# WARNING: What is normp? according to one MATLAB package description,
  # it is the cdf of a standard normal. If that's the case, this should work.  
	if (sigma_i == sigma_j) {
		delta = abs(mu_j-mu_i)/sigma_j;
		omega_ij = pnorm(-delta/2 + log(alpha_i/alpha_j)/delta)
	}
	else if (sigma_j > sigma_i)
		omega_ij = pnorm(-c1+sq_c2) - pnorm(-c1-sq_c2)
	else
		omega_ij = pnorm(-c1-sq_c2) + 1 - pnorm(-c1+sq_c2)
	return (omega_ij)
}

# Returns a term involving misclassification rates given phi.
GetMisclTerm <- function(phi) {
  alphaset <- phi$alphaset
  muset    <- phi$muset
  sigmaset <- phi$sigmaset
  m        <- length(alphaset)
  phimat   <- cbind(alphaset, muset, sigmaset) # each row represents a component 
  
	omega_1_2 <- GetOmegaIJ(phimat[1,],phimat[2,])
	omega_2_1 <- GetOmegaIJ(phimat[2,],phimat[1,])
	omega_12 <-(omega_1_2+omega_2_1)/2
	if (m == 2) # ln(omega_12 / (1-omega_12))
		return (log(omega_12/(1-omega_12)))  
	
	omega_2_3 <- GetOmegaIJ(phimat[2,],phimat[3,])
	omega_3_2 <- GetOmegaIJ(phimat[3,],phimat[2,])
	omega_23 <-(omega_2_3+omega_3_2)/2 
	if (m == 3) # ln(omega_12 omega_23 (1-omega_12)(1-omega_23))
		return (log(omega_12*omega_23/(1-omega_12)/(1-omega_23)))  
	
	omega_3_4 <- GetOmegaIJ(phimat[3,],phimat[4,])
	omega_4_3 <- GetOmegaIJ(phimat[4,],phimat[3,])
	omega_34 <-(omega_3_4+omega_4_3)/2  
	# (m == 4) # ln(omega_12 omega_23 omega_34 (1-omega_12)(1-omega_23)(1-omega_34))
	return (log(omega_12*omega_23*omega_34/(1-omega_12)/(1-omega_23)/(1-omega_34)))
  
}

# Returns a term involving a given phi.
GetATerm <- function(phi) {
	m <- length(phi$alphaset)
	a <- phi$a
	return (log(a/(0.2-a)))
}

# generates EM test result according to the dimension of X
performEMtest <- function (sample, an, m)
{
  library(doParallel) # workers might need information
  library(normalregMix2Test)  # workers might need information
  return (normalmixMEMtest (sample, m = m, z = NULL, an = an, c(0.1,0.3,0.5),
                              crit.method = "asy",  parallel.method = "none"))
}

# Returns frequency that the null H0: m=1 is rejected
# out of replications of given an and data that consists of columns of samples
GetSimulatedTypeIError <- function (an, data, m, crit = 0.05, rmpi = TRUE) {
  if (rmpi) {
    # need to transform data (matrix) to a list first.
    ldata <- lapply(seq_len(ncol(data)), function(i) data[,i])
    out  <- mpi.applyLB(ldata, performEMtest, an = an, m = m)
  }
  else
    out <- apply(data, 2, performEMtest, an = an, m = m)
  pvals <- sapply(out, "[[", "pvals")
  return (mean(pvals[2,] < crit))
}

# Generate a column that represents a sample using phi given.
GenerateSample <- function(phi)
{
	alphaset <- phi$alphaset
	muset 	 <- phi$muset
	sigmaset <- phi$sigmaset
	n				 <- phi$n
	# initialize phi in a matrix form; each row represents phi of a subcomponent
	phimat <- cbind(alphaset, muset, sigmaset)  

	# create an sample; each element represents n data created from a subcomponent
	sample <- apply(phimat, 1, function(row) row[1]*rnorm(n, mean = row[2], sd = row[3]))
	sample <- apply(sample, 1, sum) # add them up to form a full model
	
	return (sample)
}

# Generate a pair of phi and data, where data is generated by replication.
GeneratePhiDataPairs <- function(phi, rep) {
  # data is an (n rep) matrix whose column represents a sample of size n,  
  data <- do.call(cbind, replicate(rep, GenerateSample(phi = phi), simplify = FALSE))
  return (list(phi = phi, data = data))
}

# Generate data for regression.
GetDataForRegression <- function(aset, nset, alphasets, musets, sigmasets, 
																 rep = 2000, continue = 1)
{
  # initialization
  SEED <- 123456
  set.seed(SEED)
  phiset <- expand.grid(a=aset, n=nset, 
						alphaset=alphasets, muset=musets, sigmaset=sigmasets)
	# create data first for reproducibility					
  phidatapairs <- apply(phiset, 1, GeneratePhiDataPairs, rep) # list of (phi data)
	regdata <- list()
  for (i in continue:length(phidatapairs)) {
		phi <- phidatapairs[[i]]$phi
		data <- phidatapairs[[i]]$data
		a <- phi$a
		n <- phi$n
		m <- length(phi$alphaset)
		aterm <- GetATerm(phi)
		misclterm <- GetMisclTerm(phi)
		phat <- GetSimulatedTypeIError(phi$a, data, m)
		regdata[[i]] <- list(y = log(phat/(0.1-phat)), 
												 aterm = aterm, misclterm = misclterm, nterm = 1/n, 
												 a=a, phat = phat)
    df <- data.frame(matrix(unlist(regdata), ncol = length(regdata[[1]]), byrow=T))
    colnames(df) <- names(regdata[[1]])
    print(df) # save every time
  }
  return (regdata)
}

# Rmpi setup 
print("collecting workers..")
    mpi.spawn.Rslaves()
    mpi.setup.rngstream()
    mpi.bcast.Robj2slave(performEMtest, all=TRUE)
print("workers loaded.")

# ====== BEGIN EXPERIMENT ======
## 1. Initialization
# Test
# Case when m = 2 
aset <- c(0.04, 0.07, 0.1, 0.13, 0.16)
nset <- c(100, 300, 500)
alphasets <- list(c(0.25, 0.75), c(0.5, 0.5))
musets 		<- list(c(-1.5, 1.5), c(-2, 2), c(-2.5, 2.5))
sigmasets <- list(c(1, 1), c(1.5, 0.75))

## 2. Generate data
regdata <- GetDataForRegression(aset, nset, alphasets, musets, sigmasets)
df <- data.frame(matrix(unlist(regdata), ncol = length(regdata[[1]]), byrow=T))
colnames(df) <- names(regdata[[1]])
print(df)

## 3. Do regression 
df$phat <- NULL # phat itself is not used for regression.
df$a <- NULL # a as well
reg <- lm(y ~ ., data = df)
print(summary(reg))
intercept <- coef(summary(reg))["(Intercept)", "Estimate"]
atermcoeff <- coef(summary(reg))["aterm", "Estimate"]
miscltermcoeff <- coef(summary(reg))["misclterm", "Estimate"]
ntermcoeff <- coef(summary(reg))["nterm", "Estimate"]
qcoeffs <- -c(intercept, miscltermcoeff, ntermcoeff)/atermcoeff
print(qcoeffs)
# ====== END OF EXPERIMENT ======

# Rmpi termination
    mpi.close.Rslaves()