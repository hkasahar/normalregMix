#install.packages("normalregMix2Test_1.0.tar.gz", repos = NULL, type="source")
library(snow)
library(doParallel)
library(Rmpi)
library(normalregMix2Test)

# Returns a misclassification rate omega_ji given two components i, j,
# i.e. the probability of choosing component j where
# the true model is ith component.  
GetOmegaJI <- function(phi_i, phi_j) {
  alpha_i <- phi_i[[1]
  alpha_j <- phi_j[[1]
  mu_i <- phi_i[2]
  mu_j <- phi_j[2]
  sigma_i <- phi_i[3]
  sigma_j <- phi_j[3]
  
  a <- (1/sigma_j^2 - 1/sigma_i^2)
  b <- mu_i / sigma_i^2 - mu_j / sigma_j^2
  c <- mu_j^2 / sigma_j^2 - mu_i^2 / sigma_i^2

  if (sigma_i == sigma_j)
    if (mu_i > mu_j)
      omega_ji = pnorm((2 * log(alpha_j/alpha_i) - c)/(2*b), 
                       mean = mu_i, sd = sigma_i)
    else
      omega_ji = 1 - pnorm((2 * log(alpha_j/alpha_i) - c)/(2*b), 
                           mean = mu_i, sd = sigma_i)
  else {
    d <- 2 * log(alpha_j * sigma_i / (alpha_i * sigma_j)) - c + (b^2 / a)
    da <- max(d/a, 0)
    if (sigma_i > sigma_j)
      omega_ji = pnorm(sqrt(da)-b/a, mean = mu_i, sd = sigma_i) -
                 pnorm(-sqrt(da)-b/a, mean = mu_i, sd = sigma_i)
    else 
      omega_ji = 1 + 
                  pnorm(-sqrt(da)-b/a, mean = mu_i, sd = sigma_i) -
                  pnorm(sqrt(da)-b/a, mean = mu_i, sd = sigma_i)
  }
  return (omega_ji)
}

# Returns a term involving misclassification rates given phi.
GetMisclTerm <- function(phi) {
  alphaset <- phi$alphaset
  muset    <- phi$muset
  sigmaset <- phi$sigmaset
  m        <- length(alphaset)
  phimat   <- cbind(alphaset, muset, sigmaset) # each row represents a component 
  
	omega_2_1 <- GetOmegaJI(phimat[1,],phimat[2,])
	omega_1_2 <- GetOmegaJI(phimat[2,],phimat[1,])
	omega_12  <- (omega_1_2 + omega_2_1)/2
	if (m == 2) # ln(omega_12 / (1-omega_12))
		return (log(omega_12/(1-omega_12)))  
		
	omega_3_2 <- GetOmegaJI(phimat[2,],phimat[3,])
	omega_2_3 <- GetOmegaJI(phimat[3,],phimat[2,])
	omega_23  <- (omega_2_3 + omega_3_2)/2
	if (m == 3) # ln(omega_12 omega_23 / (1-omega_12)(1-omega_23))
		return (log(omega_12*omega_23/(1-omega_12)/(1-omega_23)))  
	
	omega_4_3 <- GetOmegaJI(phimat[3,],phimat[4,])
	omega_3_4 <- GetOmegaJI(phimat[4,],phimat[3,])
	omega_34  <- (omega_3_4 + omega_4_3)/2
	# (m == 4) # ln(omega_12 omega_23 omega_34 / (1-omega_12)(1-omega_23)(1-omega_34))
	return (log(omega_12*omega_23*omega_34/(1-omega_12)/(1-omega_23)/(1-omega_34)))
  
}

# Returns a term involving a given phi.
GetATerm <- function(phi) {
	m <- length(phi$alphaset)
	a <- phi$a
	return (log(a/(0.2-a)))
}

# generates EM test result according to the dimension of X
performEMtest <- function (sample, an, m)
{
  library(doParallel) # workers might need information
  library(normalregMix2Test)  # workers might need information
  return (normalmixMEMtest (sample, m = m, z = NULL, an = an, c(0.1,0.3,0.5),
                              crit.method = "asy",  parallel.method = "none"))
}

# Returns frequency that the null H0: m=1 is rejected
# out of replications of given an and data that consists of columns of samples
GetSimulatedTypeIError <- function (an, data, m, crit = 0.05, rmpi = TRUE) {
  if (rmpi) {
    # need to transform data (matrix) to a list first.
    ldata <- lapply(seq_len(ncol(data)), function(i) data[,i])
    out  <- mpi.applyLB(ldata, performEMtest, an = an, m = m)
  }
  else
    out <- apply(data, 2, performEMtest, an = an, m = m)
  pvals <- sapply(out, "[[", "pvals")
  return (mean(pvals[2,] < crit))
}

# Generate a column that represents a sample using phi given.
GenerateSample <- function(phi)
{
	alphaset <- phi$alphaset
	muset 	 <- phi$muset
	sigmaset <- phi$sigmaset
	n				 <- phi$n
	# initialize phi in a matrix form; each row represents phi of a subcomponent
	phimat <- cbind(alphaset, muset, sigmaset)  

	# create a sample; each element represents n data created from a subcomponent
	sample <- apply(phimat, 1, function(row) row[1]*rnorm(n, mean = row[2], sd = row[3]))
	sample <- apply(sample, 1, sum) # add them up to form a full model
	
	return (sample)
}

# Generate a pair of phi and data, where data is generated by replication.
GeneratePhiDataPairs <- function(phi, rep) {
  # data is an (n rep) matrix whose column represents a sample of size n,  
  data <- do.call(cbind, replicate(rep, GenerateSample(phi = phi), simplify = FALSE))
  return (list(phi = phi, data = data))
}

# Generate data for regression.
GetDataForRegression <- function(aset, nset, alphasets, musets, sigmasets, 
																 rep = 2000, continue = 1)
{
  # initialization
  SEED <- 123456
  set.seed(SEED)
  phiset <- expand.grid(a=aset, n=nset, 
						alphaset=alphasets, muset=musets, sigmaset=sigmasets)
	# create data first for reproducibility					
  phidatapairs <- apply(phiset, 1, GeneratePhiDataPairs, rep) # list of (phi data)
	regdata <- list()
  for (i in continue:length(phidatapairs)) {
		phi <- phidatapairs[[i]]$phi
		data <- phidatapairs[[i]]$data
		a <- phi$a
		n <- phi$n
		m <- length(phi$alphaset)
		aterm <- GetATerm(phi)
		misclterm <- GetMisclTerm(phi)
		phat <- GetSimulatedTypeIError(phi$a, data, m)
		regdata[[i]] <- list(y = log(phat/(0.15-phat)), 
												 aterm = aterm, misclterm = misclterm, nterm = 1/n, 
												 a=a, phat = phat)
    df <- data.frame(matrix(unlist(regdata), ncol = length(regdata[[1]]), byrow=T))
    colnames(df) <- names(regdata[[1]])
    print(df) # save every time
  }
  return (regdata)
}

# Rmpi setup 
print("collecting workers..")
    mpi.spawn.Rslaves()
    mpi.setup.rngstream()
    mpi.bcast.Robj2slave(performEMtest, all=TRUE)
print("workers loaded.")

# ====== BEGIN EXPERIMENT ======
## 1. Initialization
# Case when m = 3
aset <- c(0.04, 0.07, 0.1, 0.13, 0.16)
nset <- c(100, 300, 500)
alphasets <- list(c(0.33, 0.33, 0.34)) 
musets 		<- list(c(-4, 0, 4), c(-4, 0, 5), c(-5, 0, 5), c(-4, 0, 6), c(-5, 0, 6), c(-6, 0, 6))
sigmasets <- list(c(1, 1, 1), c(0.75, 1.5, 0.75))

## 2. Generate data
regdata <- GetDataForRegression(aset, nset, alphasets, musets, sigmasets)
df <- data.frame(matrix(unlist(regdata), ncol = length(regdata[[1]]), byrow=T))
colnames(df) <- names(regdata[[1]])
print(df)

## 3. Do regression 
df$phat <- NULL # phat itself is not used for regression.
df$a <- NULL # a as well
reg <- lm(y ~ ., data = df)
print(summary(reg))
intercept <- coef(summary(reg))["(Intercept)", "Estimate"]
atermcoeff <- coef(summary(reg))["aterm", "Estimate"]
miscltermcoeff <- coef(summary(reg))["misclterm", "Estimate"]
ntermcoeff <- coef(summary(reg))["nterm", "Estimate"]
qcoeffs <- -c(intercept, miscltermcoeff, ntermcoeff)/atermcoeff
print(qcoeffs)
# ====== END OF EXPERIMENT ======

# Rmpi termination
    mpi.close.Rslaves()